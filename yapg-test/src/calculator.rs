# [allow (warnings)] use crate :: ast :: * ; impl yapg :: grammar :: TerminalKind for Token { fn id (& self) -> & str { match self { Token :: Plus => "+" , Token :: Star => "*" , Token :: LParen => "(" , Token :: RParen => ")" , Token :: Identifier (..) => "identifier" , } } } impl From < Token > for Value { fn from (token : Token) -> Self { Value :: Token (token) } } # [derive (Debug)] enum Value { ExprOp (Opcode) , Expr (Box < Expr >) , Factor (Box < Expr >) , FactorOp (Opcode) , Term (Box < Expr >) , Token (Token) } impl Value { fn into_exprop (self) -> Opcode { match self { Value :: ExprOp (v) => v , _ => panic ! ("expected ExprOp node") , } } fn into_expr (self) -> Box < Expr > { match self { Value :: Expr (v) => v , _ => panic ! ("expected Expr node") , } } fn into_factor (self) -> Box < Expr > { match self { Value :: Factor (v) => v , _ => panic ! ("expected Factor node") , } } fn into_factorop (self) -> Opcode { match self { Value :: FactorOp (v) => v , _ => panic ! ("expected FactorOp node") , } } fn into_term (self) -> Box < Expr > { match self { Value :: Term (v) => v , _ => panic ! ("expected Term node") , } } fn into_token (self) -> Token { match self { Value :: Token (v) => v , _ => panic ! ("expected Token node") , } } } # [allow (clippy :: ptr_arg)] fn rule_0 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { unreachable ! ("rule 0's action should never be called") } fn rule_1 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg3 = stack . pop () . unwrap () . into_factor () ; let arg2 = stack . pop () . unwrap () . into_exprop () ; let arg1 = stack . pop () . unwrap () . into_expr () ; let args = (arg1 , arg2 , arg3) ; let result = SemanticAction :: rule1 (action , args) ; Value :: Expr (result) } fn rule_2 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg1 = stack . pop () . unwrap () . into_factor () ; let result = { arg1 } ; Value :: Expr (result) } fn rule_3 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg1 = stack . pop () . unwrap () . into_token () ; let result = { Opcode :: Add } ; Value :: ExprOp (result) } fn rule_4 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg3 = stack . pop () . unwrap () . into_term () ; let arg2 = stack . pop () . unwrap () . into_factorop () ; let arg1 = stack . pop () . unwrap () . into_factor () ; let result = { Box :: new (Expr :: Op (arg1 , arg2 , arg3)) } ; Value :: Factor (result) } fn rule_5 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg1 = stack . pop () . unwrap () . into_term () ; let result = { arg1 } ; Value :: Factor (result) } fn rule_6 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg1 = stack . pop () . unwrap () . into_token () ; let result = { Opcode :: Mul } ; Value :: FactorOp (result) } fn rule_7 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg1 = stack . pop () . unwrap () . into_token () ; let result = { Box :: new (Expr :: Identifier (arg1 . into ())) } ; Value :: Term (result) } fn rule_8 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg3 = stack . pop () . unwrap () . into_token () ; let arg2 = stack . pop () . unwrap () . into_expr () ; let arg1 = stack . pop () . unwrap () . into_token () ; let result = { arg2 } ; Value :: Term (result) } type ActionFn = fn (& mut SemanticAction , & mut Vec < Value >) -> Value ; const RULE_TABLE : & [ActionFn] = & [rule_0 , rule_1 , rule_2 , rule_3 , rule_4 , rule_5 , rule_6 , rule_7 , rule_8] ; const FINAL_STATES_SET : phf :: Set < usize > = phf :: phf_set ! { 1usize , 3usize , 6usize , 12usize , 2usize , 4usize , 13usize , 9usize , 11usize } ; const START_STATE : usize = 0usize ; const END_STATE : usize = 3usize ; static TRANSITION0 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { "Factor" => 4usize , "Expr" => 3usize , "Term" => 1usize , "identifier" => 2usize , "(" => 5usize } ; static TRANSITION1 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { } ; static TRANSITION2 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { } ; static TRANSITION3 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { "+" => 6usize , "ExprOp" => 7usize } ; static TRANSITION4 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { "FactorOp" => 8usize , "*" => 9usize } ; static TRANSITION5 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { "(" => 5usize , "Term" => 1usize , "Expr" => 10usize , "Factor" => 4usize , "identifier" => 2usize } ; static TRANSITION6 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { } ; static TRANSITION7 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { "Factor" => 11usize , "Term" => 1usize , "(" => 5usize , "identifier" => 2usize } ; static TRANSITION8 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { "Term" => 12usize , "identifier" => 2usize , "(" => 5usize } ; static TRANSITION9 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { } ; static TRANSITION10 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { ")" => 13usize , "ExprOp" => 7usize , "+" => 6usize } ; static TRANSITION11 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { "FactorOp" => 8usize , "*" => 9usize } ; static TRANSITION12 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { } ; static TRANSITION13 : phf :: Map < & 'static str , usize > = phf :: phf_map ! { } ; static TRANSITIONS : & [& phf :: Map < & 'static str , usize >] = & [& TRANSITION0 , & TRANSITION1 , & TRANSITION2 , & TRANSITION3 , & TRANSITION4 , & TRANSITION5 , & TRANSITION6 , & TRANSITION7 , & TRANSITION8 , & TRANSITION9 , & TRANSITION10 , & TRANSITION11 , & TRANSITION12 , & TRANSITION13] ; const REDUCE_RULE : & [Option < usize >] = & [None , Some (5usize) , Some (7usize) , Some (0usize) , Some (2usize) , None , Some (3usize) , None , None , Some (6usize) , None , Some (1usize) , Some (4usize) , Some (8usize)] ; const RULES : & [(& str , & [& str])] = & [("Expr'" , & ["Expr"]) , ("Expr" , & ["Expr" , "ExprOp" , "Factor"]) , ("Expr" , & ["Factor"]) , ("ExprOp" , & ["+"]) , ("Factor" , & ["Factor" , "FactorOp" , "Term"]) , ("Factor" , & ["Term"]) , ("FactorOp" , & ["*"]) , ("Term" , & ["identifier"]) , ("Term" , & ["(" , "Expr" , ")"])] ; static CONFLICT_RESOLVER : phf :: Map < usize , phf :: Set < & 'static str >> = phf :: phf_map ! { 3usize => phf :: phf_set ! { } , 11usize => phf :: phf_set ! { "+" , ")" } , 4usize => phf :: phf_set ! { "+" , ")" } } ; pub struct ExprParser < Actioner > { actioner : Actioner , } impl ExprParser < SemanticAction > { pub fn new (actioner : SemanticAction) -> Self { Self { actioner } } pub fn parse < I : Iterator < Item = Token >> (self , token_stream : std :: iter :: Peekable < I > ,) -> Option < Box < Expr >> { let actions = RULE_TABLE ; let ctx = yapg :: parser :: ParseContext { start_state : START_STATE , end_state : END_STATE , final_states : FINAL_STATES_SET , transitions : TRANSITIONS , reduce_rule : REDUCE_RULE , rules : RULES , conflict_resolver : & CONFLICT_RESOLVER , } ; let mut pda : yapg :: parser :: PdaImpl < '_ , Value , SemanticAction > = yapg :: parser :: PdaImpl :: new (START_STATE , self . actioner , actions) ; if pda . process (token_stream , & ctx) { Some (pda . final_value () . into_expr ()) } else { None } } }