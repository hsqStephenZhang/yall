use crate :: ast :: * ; # [derive (Debug)] enum Value { Expr (Box < Expr >) , ExprOp (Opcode) , Term (Box < Expr >) , Factor (Box < Expr >) , FactorOp (Opcode) , Token (Token) } impl Value { fn into_expr (self) -> Box < Expr > { match self { Value :: Expr (v) => v , _ => panic ! ("expected Expr node") , } } fn into_exprop (self) -> Opcode { match self { Value :: ExprOp (v) => v , _ => panic ! ("expected ExprOp node") , } } fn into_term (self) -> Box < Expr > { match self { Value :: Term (v) => v , _ => panic ! ("expected Term node") , } } fn into_factor (self) -> Box < Expr > { match self { Value :: Factor (v) => v , _ => panic ! ("expected Factor node") , } } fn into_factorop (self) -> Opcode { match self { Value :: FactorOp (v) => v , _ => panic ! ("expected FactorOp node") , } } fn into_token (self) -> Token { match self { Value :: Token (v) => v , _ => panic ! ("expected Token node") , } } } # [allow (clippy :: ptr_arg)] fn rule_0 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { unreachable ! ("rule 0's action should never be called") } fn rule_1 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg3 = stack . pop () . unwrap () . into_factor () ; let arg2 = stack . pop () . unwrap () . into_exprop () ; let arg1 = stack . pop () . unwrap () . into_expr () ; let args = (arg1 , arg2 , arg3) ; let result = SemanticAction :: rule1 (action , args) ; Value :: Expr (result) } fn rule_2 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg1 = stack . pop () . unwrap () . into_factor () ; let result = { arg1 } ; Value :: Expr (result) } fn rule_3 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg1 = stack . pop () . unwrap () . into_token () ; let result = { Opcode :: Add } ; Value :: ExprOp (result) } fn rule_4 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg3 = stack . pop () . unwrap () . into_term () ; let arg2 = stack . pop () . unwrap () . into_factorop () ; let arg1 = stack . pop () . unwrap () . into_factor () ; let result = { Box :: new (Expr :: Op (arg1 , arg2 , arg3)) } ; Value :: Factor (result) } fn rule_5 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg1 = stack . pop () . unwrap () . into_term () ; let result = { arg1 } ; Value :: Factor (result) } fn rule_6 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg1 = stack . pop () . unwrap () . into_token () ; let result = { Opcode :: Mul } ; Value :: FactorOp (result) } fn rule_7 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg1 = stack . pop () . unwrap () . into_token () ; let result = { Box :: new (Expr :: Identifier (arg1 . into ())) } ; Value :: Term (result) } fn rule_8 (action : & mut SemanticAction , stack : & mut Vec < Value >) -> Value { let arg3 = stack . pop () . unwrap () . into_token () ; let arg2 = stack . pop () . unwrap () . into_expr () ; let arg1 = stack . pop () . unwrap () . into_token () ; let result = { arg2 } ; Value :: Term (result) } type ActionFn = fn (& mut SemanticAction , & mut Vec < Value >) -> Value ; const RULE_TABLE : & [ActionFn] = & [rule_0 , rule_1 , rule_2 , rule_3 , rule_4 , rule_5 , rule_6 , rule_7 , rule_8] ;